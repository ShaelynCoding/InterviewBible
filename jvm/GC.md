#### 垃圾标记算法：
    - 引用计数（Reference Counting Collector）
        - 优点：简单，类似C++的shared pointer
        - 缺点：无法鉴别循环引用/效率变慢，每次指针操作可能修改计数
    - 根搜索算法（Root Tracing Collector）
        - 通过一系列“GC Roots”为起始点向下搜索引用节点，若对象到GC Roots没有任何引用链（搜索走过的路径）相连即为不可达
        - 可作为GC Roots的对象
            1. 虚拟机栈（栈帧中的本地变量表）中的引用的对象
            2. 方法区中的类静态属性引用的对象
            3. 方法区中的常量引用的对象
            4. 本地方法栈中JNI（Native方法）的引用对象
#### 回收算法
    - 标记-清除：标记后在内存中原地清除
        - 优点：对象不需要移动/只操作不存活对象
        - 缺点：效率低，由于需要维护空闲表/产生大量碎片
        - 适合：暂停时间短/存活比例高
    - 标记-整理：不直接清理回收对象，所有存活对象向一端移动，然后直接清除端边界外的内存 
        - 优点：无碎片
        - 缺点：移动存活的变量（全部遍历标记后整理），执行暂停导致GC时间延长
        - 适合：存活比例高/回收不频繁
    - 标记-复制：空间换时间，将内存分为大小相等的两块，对象区/空闲区，当对象区用完后将存活的对象复制到空闲区，只有对象区和空闲区切换的过程，程序暂停执行
        - 优点：无碎片/标志与复制同时执行
        - 缺点：额外空间，空间利用率/也需要暂停
        - 适合：存活比例少/内存申请次数多/回收不频繁
#### 分代：
    - 新生代：对象死亡率高，少量存活，适合标记-拷贝
        - Eden（80%）：大部分对象在此生成，满时触发Minor GC（从Eden copy->From)
        - From Survivor(10%):满时交换From和To（本质是数据From->To)
        - To Survivor(10%):满时将数据转到老生代

    - 老生代：存活率高，适合标记-整理/希望时间短，考虑标记-删除
        - 满时触发Full GC（新生代，老生代，永生代都回收）
    - 永生代：满时触发Full GC

#### 减少GC开销
    - 没经验不要显式调用System.gc()，因为增加了暂停次数
    - 减少临时对象的使用
    - 对象不用时最好显式置为Null，手动悬空，加快GC
    - 使用StringBuffer,而不用String来累加字符串
    - 能用基本类型如Int,Long,就不用Integer,Long对象
    - 尽量少用静态对象变量： 静态变量属于全局变量,不会被GC回收,它们会一直占用内存
    - 散对象创建或删除的时间： 集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象，也是类似的。

#### 垃圾收集器

![](garage.png)

- 组合使用（组合关系见上图）
    - 用于新生代：Serial/ParNew/Parallel Scavenge
    - 用于老生代： CMS/Serial Old/Parallel Old
- G1:独立收集器
- ZGC:JDK11的实验收集器

|收集器|线程|算法|优点|缺点|
|-----|----|---|---|---|
|Serial|单线程|复制|减少上下文切换，减少系统资源开销|执行需要暂停|
|ParNew|Serial的多线程版本|复制|多CPU下多线程执行，单CPU因为线程切换性能反而更差|执行需要暂停|
|Parallel Scavenge|多线程|复制|关注垃圾回收吞吐量||
|Serial Old|单线程|标记-整理|||
|Parallel Old|多|标记-整理|||
|CMS|Concurrent，可与工作程序并行|标记-清除|关注垃圾回收最短的停顿时间||

1. CMS
- step：
    - 初始标记：单线程执行，需要stop the world，但仅仅标记GC Roots的直接关联可达的对象
    - 并发标记：初始标记对象并发追踪标记，其他线程任可继续工作，不需停顿
    - 重新标记：标记在并发标记过程中可能产生的新垃圾。并发执行标记，但与用户程序不并发，暂停时间比初始时间长
    - 并发清除：并发清除之前标记的垃圾，其他用户线程任可工作，不需要停顿
- 缺点：
    - 标记-清除算法会导致内存碎片多（因为用户线程继续执行，运行的资源不受影响，不能使用标记-整理）
    - CMS并发能力依赖于CPU资源，CPU资源紧张的情况下性能差
    - 并发清除：用户程序仍运行会产生新垃圾，此阶段垃圾不会在本次GC中回收，故GC不能在内存耗尽时进行
2. G1（Garbage First）
- 内存分为多个大小相同的区域，每个区域都有自己的分代属性，维护一个remembered set（记录对象引用的情况，避免全盘扫描）
- 两种GC模式：
    1. young GC:关注所有年轻代的region，通过控制收集年轻代的region个数，从而控制GC时间
    2. Mixed GC:关注所有年轻代的region，并且+预测计算最大收益的若干老年代region
- 步骤：最后一步筛选回收，根据GC模式回收，stw执行，算法：标记-整理

3. ZGC
- 除了初始标记STW
- 着色指针Colored pointer/读屏障Load Barrier
